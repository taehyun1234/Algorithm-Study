Hash는 key와 value로 1대1 매칭되는 자료구조이다.
이 Hash라는 자료구조를 이용하면 O(1)이라는 어마어마한 성능을 낼 수 있다.
이건 어디까지나, 정말 이상적으로 했을 경우 O(1)이고, 현실은 그렇게 낼 수 없다. 그렇다면, 뭐가 문제길래? 라는 의문을 가질 수 있다.
딱 살펴보면, Hash는 Key-Value 1대1 매칭이라고 했지만, value값이 간혹 겹쳐버리는 현상이 일어난다.
이를 Crushing(충돌 현상)이라고 한다. 그러므로, 충돌현상이 일어났을 때 그에 따른 문제 해결이 필요하다. 해결 방안은 다음과 같다. 

1. Chaining 기법
- 같은 주소로 Hashing 되는 원소를 List를 이용하여 관리한다. 원소를 삭제하거나 변경하는 작업이 간단하다. 
하지만, List를 이용하여 체이닝을 구현할 경우, 같은 주소에 많은 양의 데이터가 List에 추가될 경우, O(n)이 되어 버릴 수 있기 때문에, 성능이 좋지 않다. 
그래서 List 대신 Tree를 사용하여 O(logN)이 되도록 구현하여 탐색 성능을 높일 수 있다.

2. 주소 개방법
- 충돌이 났을 때, 비어있는 자리에 할당을 해준다.
개방 주소법의 경우 여러가지 방법이 존재한다. (선형 탐색, 이차 검색법, 이중 해싱 등등)
>>
1. 선형 탐색의 경우, 해시 충돌이 발생할 때, 다음 버킷, 또는 몇개를 건너 뛰어 데이터를 삽입한다.
장점 : 구조가 간단하고, 캐시의 효율이 높음.
단점 : 데이터가 많아질수록 해시테이블 전체를 다 검색해야 하는 상황이 생김. 데이터의 클러스터링에 취약함.

2. 2차검색법의 경우 원래 저장할 위치로부터 떨어진 영역을 차례대로 검색하여 첫번째 빈 영역에 키를 저장하는 방법
- 이중해시와 선형탐색의 중간정도 성능

3. 이중 해시
- 해시 충돌할 경우 다른 함수를 한번 더 적용한 결과를 이용.
- 많은 연산량을 요구함.

Chaining과 주소 개방법의 차이는 충돌이 발생했을 때 Chaining은 List나 Tree와 같은 추가적인 메모리를 사용하는 반면, 주소 개방법은 Hash Table의 비어있는 공간을 이용한다.
그래서, 메모리 추가할당이 없기 때문에 데이터를 추가했을 때 메모리 할당에 대한 오버헤드가 없다. 
 
 선형 탐색의 경우 데이터가 많지 않을 때는 Chaining에 비해 성능이 훨씬 좋다. 그 이유는, 지역 참조성에 의해 연속된 메모리(선형적)에 저장되기 때문에 비선형적인 Chaining에 비해
 Hit 적중률이 더 높고, 그로 인해 더 빠르다. 하지만, 데이터가 많아질 수록 Chaining에 비해 성능이 떨어지게 된다.(빈 버킷이 쭉쭉 뒤로 밀리면 그 구간을 모두 탐색해야함. 그 탐색 구간에는
 상관없는 데이터들이 있을 수 있음.)

---------------------------------------------------------------------------------------------------------------
사실 충돌이 잦을 경우, 해시테이블의 장점인 Key Value 구조로 O(1)의 성능을 보여줄 수 없다고 볼 수 있다. 
그러므로, 충돌을 최소화 하기 위해서는 IndexMapping 자체를 효율적으로 구현해야 한다.

 
좋은 Hash 함수의 조건

- 입력 원소가 Hash Table에 골고루 저장되어야 한다.

Hash Table이 적합하지 않은 경우
- 정렬된 데이터가 필요할 때
- 멀티미디어 데이터를 저장할 때
- 키의 길이가 길고 가변적이여서 키에 대한 사전 검색이 필요할 때
- 조건에 따라 데이터가 동적으로 변해야 할 때
- 데이터의 키가 유일하지 않을 때